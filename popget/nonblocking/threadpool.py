import concurrent.futures
from functools import partial
from six import add_metaclass
from typing import Type, Any

import requests
from requests_futures.sessions import FuturesSession

from popget.client import (
    APIClient as BaseAPIClient,
    APIClientMetaclass,
    ConfigClass as BaseConfigClass,
    method_factory,
)
from popget.endpoint import APIEndpoint
from popget.utils import classproperty


class ConfigClass(BaseConfigClass):

    _async_session: FuturesSession = None

    async_method_template = 'async_{}'

    def __init__(self, config):
        self.async_method_template = getattr(config, 'async_method_template', self.async_method_template)
        super(ConfigClass, self).__init__(config)

    @classproperty
    def async_session(cls)  -> FuturesSession:
        if not cls._async_session:
            cls._async_session = FuturesSession(session=cls.session)
        return cls._async_session


class AsyncAPIClientMetaclass(APIClientMetaclass):

    config_class = ConfigClass

    @staticmethod
    def add_methods_for_endpoint(methods: dict[str, classmethod], name: str, endpoint: APIEndpoint, config: Any) -> None:
        methods[name] = classmethod(method_factory(endpoint, '_make_request'))
        methods[config.async_method_template.format(name)] = classmethod(
            method_factory(endpoint, '_make_async_request')
        )


@add_metaclass(AsyncAPIClientMetaclass)
class APIClient(BaseAPIClient):

    _config: ConfigClass

    @classmethod
    def _make_async_request(
        cls, method: str, url: str, session: requests.Session | None = None, *args, **kwargs
    ) -> concurrent.futures.Future:
        """
        Don't call this directly. Instead, add APIEndpoint instances to your
        APIClient sub-class definition. Accessor methods will be generated by
        the APIClientMetaclass magic.

        Kwargs:
            method: name of a method on the `requests` lib, such as 'get'
            url: url of endpoint to call, with all params substituted in
            *args
            **kargs
                passed through to underlying `requests` method

        Returns:
            Future object. Use the standard concurrent.futures API to await
            the result.
        """
        cls._request_kwargs(method, url, args, kwargs)
        if session is None:
            session = cls._config.session
        call = partial(getattr(session, method), url, *args, **kwargs)
        return cls._config.async_session.executor.submit(cls.handle, call, url)
